<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python链表]]></title>
    <url>%2F2018%2F08%2F01%2Fpython%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表是物理存储单元非连续的,非顺序的存储结构,数据元素的逻辑顺序是通过指针去实现的.节点包含两个部分,一个是数据存储域,另一个指针作用域 1.带虚拟头结点的链表集合 在头结点插入元素时间复杂度为O(1),在尾节点插入元素时间复杂度为O(n),在头部删除元素时间复杂度为O(1)在其他地方删除元素时间复杂度为O(n) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Node(object): def __init__(self, value, next=None): self.value = value self.next = nextclass LinkList(object): def __init__(self): self.__dummy_head = Node(None, None) self.__size = 0 @property def size(self): return self.__size @size.setter def size(self, value): self.__size = value def is_empty(self): return self.size == 0 def get_head(self): return self.get(0) def get_last(self): return self.get(self.size - 1) def add_head(self, value): self.add(0, value) def add_last(self, value): self.add(self.size - 1, value) def add(self, index, value): if index &gt; self.size or index &lt; 0: raise ValueError('索引超出边界') pre_node = self.__dummy_head while index &gt; 0: pre_node = pre_node.next index -= 1 pre_node.next = Node(value, pre_node.next) self.size += 1 def get(self, index): if index &lt; 0 or index &gt; self.size - 1: raise ValueError('索引超出边界') cur_node = self.__dummy_head.next while index &gt; 0: index -= 1 cur_node = cur_node.next return cur_node def remove(self, index): pre = self.__dummy_head while index &gt; 0: pre = pre.next index -= 1 cur = pre.next pre.next = cur.next cur.next = None self.size -= 1 def remove_head(self): self.remove(0) def remove_last(self): self.remove(self.size - 1) 2.基于链表实现的堆栈 push 跟pop都是在头结点进行操作所以时间复杂度为O(1),所以作为堆栈效率很高 12345678910111213141516171819202122232425262728293031class LinkListStack(object): def __init__(self): self.head = None self.__size = 0 @property def size(self): return self.__size @size.setter def size(self, value): self.__size = value def is_empty(self): return self.size == 0 def push(self, value): self.head = Node(value,self.head) self.size+=1 def pop(self): head = self.head self.head = head.next head.next = None self.size-=1 return head def peek(self): return self.head]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现二分搜索树]]></title>
    <url>%2F2018%2F07%2F30%2F%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二分搜索树不仅可以查找数据,而且还可以高效的插入删除数据.二分搜索树的特点:每个节点的数值都大于左子树的数值,小于右子树的数值,他不一定是一个完全的二叉树. 1.首先我们新建一个节点命名为Node,它包含左子树,右子树,以及数值 12345678class Node(object): def __init__(self, value=None): # 包含的数值 self.value = value # 左子树,默认为空 self.left_tree = None # 右子树,默认为空 self.right_tree = None 2.新建一个二分搜索树 12345678910111213141516171819class BST(object): def __init__(self): #默认根节点为空 self.__root = None #默认size的大小为0 self.__size = 0 #获取size的大小 @property def size(self): return self.__size #设置size的大小 @size.setter def size(self, value): self.__size = value #判断二分搜索树是否为空 def is_empty(self): return self.size == 0 3.当我们要添加数据到二分搜索树中,我们需要添加一个add方法具体实现如下, 用递归的方式去实现 12345678910111213def add(self, value): self.__root = self.__add(self.__root, value)def __add(self, node, value): if node is None: self.size+=1 return Node(value) if value &lt; node.value: node.left_tree = self.__add(node.left_tree, value) if value &gt; node.value: node.right_tree = self.__add(node.right_tree, value) return node 非递归的添加实现 123456789101112131415161718192021222324def no_recu_add(self, value): if self.__root is None: self.__root = Node(value) self.size+=1 else: self.__no_recu_add(self.__root, value)def __no_recu_add(self, node, value): while node: if value &lt; node.value: temp = (0, node) node = node.left_tree elif value &gt; node.value: temp = (1, node) node = node.right_tree elif value == node.value: return node if temp[0] == 0: temp[1].left_tree = Node(value) else: temp[1].right_tree = Node(value) self.size+=1 二分搜索的的查询某个元素(递归的方式实现) 1234567891011121314def search(self,value): if self.__root: return self.__search(self.__root,value)def __search(self,node,value): #如果当前节点为空表明没有查询到 if node is None: return None #去左子树中查询 if value&lt;node.value: return self.__search(node.left_tree,value) #去右子树中查询 if value&gt;node.value: return self.__search(node.right_tree,value) return node 二分搜索树查询非递归的实现 1234567891011121314151617def no_recur_search(self, value): if self.__root: return self.__no_recur_search(self.__root, value)def __no_recur_search(self, node, value): #判断节点是否为空 while node: #去左子树中查询 if value &lt; node.value: node = node.left_tree #去右子树中查询 elif value &gt; node.value: node = node.right_tree #查询到 elif value == node.value: return node #未查询到 return None 二分搜索树是否包含某个元素的判断 123456789101112def contains(self, value): if self.__root: return self.__contains(self.__root, value)def __contains(self, node, value): if node is None: return None if value &lt; node.value: return self.__search(node.left_tree, value) if value &gt; node.value: return self.__search(node.right_tree, value) return node 二分搜索树的前序遍历(递归方式) 123456789101112def pre_travel(self): if self.__root: self.__pre_travel(self.__root)def __pre_travel(self, node): if node: #打印当前节点 print(node.value) #遍历左子树 self.__pre_travel(node.left_tree) #遍历右子树 self.__pre_travel(node.right_tree) 二分搜索树的前序遍历(用栈实现) 1234567891011121314151617181920212223def no_recur_pre_travel_stack(self): if self.__root: self.__no_recur_pre_travel_stack(self.__root)def __no_recur_pre_travel_stack(self, node): #建立一个栈 stack = [] #把根节点压入栈 stack.append(node) #当栈不为空 while stack: #把栈顶元素弹出 top = stack.pop() #打印当前节点值 print(top.value, end=',') #如果右子树不为空那么先把右子树压入栈, if top.right_tree: stack.append(top.right_tree) #如果左子树不为空,再把左子树压入栈 if top.left_tree: stack.append(top.left_tree) #栈具有先进后出的特性,因为二分搜索树的前序遍历是先打印当前节点,在打印左子树,再打印右子树 #所以需要先把右子树压入栈 二分搜索树的中序遍历 123456789101112def inner_travel(self): if self.__root: self.__inner_travel(self.__root)def __inner_travel(self, node): if node: if node.left_tree: self.__inner_travel(node.left_tree) print(node.value, end=',') if node.right_tree: self.__inner_travel(node.right_tree) 二分搜索树的中序遍历非递归实现 123456789101112131415161718192021def no_recur_inner_travel(self): if self.__root: self.__no_recur_inner_travel(self.__root)def __no_recur_inner_travel(self, node): #新建一个栈 stack = [] #当node不为空或者栈不为空 while node or stack: #当node不为空 while node: #将当前节点添加进入栈 stack.append(node) #把当前节点的左子树作为当前节点,如果左子树还是不为空,那么会继续执行再把左子树的左子树的当做当前节点,如果为空le node = node.left_tree #说明左子树已经为空,那么将栈顶元素弹出,查看栈顶元素的右子树作为当前树进行外层的while判断 if stack: top = stack.pop() node = top.right_tree print(top.value, end=',') 二分搜索树的后续遍历 12345678910111213def post_travel(self): if self.__root: self.__post_travel(self.__root)def __post_travel(self, node): if node: if node.left_tree: self.__inner_travel(node.left_tree) if node.right_tree: self.__inner_travel(node.right_tree) print(node.value, end=',') 利用队列实现二分搜索树的层序遍历 12345678910111213141516171819def level_travel(self): if self.__root: self.__level_travel(self.__root)def __level_travel(self,node): #建立空的队列 queue=[] #把根节点添加到队列 queue.append(node) #如果队列不为空 while queue: #弹出队首元素 first=queue.pop(0) print(first.value,end=',') #如果左子树不为空,则入队 if first.left_tree: queue.append(first.left_tree) #如果右子树不为空,则入队 if first.right_tree: queue.append(first.right_tree) 利用二分搜索树查询最小值 12345678910def find_min(self): if self.__root: return self.__find_min(self.__root) def __find_min(self, node): #如果当前节点的左子树为空,那么当前节点就是最小值 if node.left_tree is None: return node #继续递归遍历 return self.__find_min(node.left_tree) 利用二分搜索树查询最大值 1234567def find_max(self): if self.__root: return self.__find_max(self.__root)def __find_max(self, node): if node.right_tree is None: return node return self.__find_max(node.right_tree) 删除二分搜索树的最小值 123456789101112def del_min(self): if self.__root: self.__root = self.__del_min(self.__root)def __del_min(self, node): if node.left_tree is None: replace_node = node.right_tree node.right_tree = None self.size -= 1 return replace_node node.left_tree = self.__del_min(node.left_tree) return node 删除二分搜索树的最大值 123456789101112def del_max(self): if self.__root: self.__root = self.__del_max(self.__root)def __del_max(self, node): if node.right_tree is None: replace_node = node.left_tree self.size -= 1 node.left_tree = None return replace_node node.right_tree = self.__del_max(node.right_tree) return node 删除二分搜索树的任意节点 12345678910111213141516171819202122232425262728293031323334353637383940def remove_node(self, value): if self.__root: self.__root = self.__remove_node(self.__root, value)def __remove_node(self, node, value): #节点为空说明不存在 if node is None: return None #去左子树查找元素 if value&lt;node.value: node.left_tree = self.__remove_node(node.left_tree,value) return node #去右子树查找元素 if value&gt;node.value: node.right_tree = self.__remove_node(node.right_tree,value) return node #找到节点 #左子树为空 if node.left_tree is None: #将该节点的右子树作为该节点的替代节点 replace_node = node.right_tree self.size-=1 node.right_tree=None return replace_node elif node.right_tree is None: #将该节点的左子树作为该节点的替代节点 replace_node = node.left_tree self.size-=1 node.left_tree=None return replace_node else: #左右子树不为空,首先找出右子树最小的元素 replace_node=self.__find_min(node.right_tree) #代替节点的左子树还是原来节点的左子树 replace_node.left_tree=node.left_tree #替代节点的右子树为删除该节点右子树的最小值以后的 replace_node.right_tree=self.__del_min(node.right_tree) node.left_tree=None node.right_tree=None return replace_node]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-fsm的用法]]></title>
    <url>%2F2018%2F07%2F26%2Fdjango-fsm%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[django有限状态机为django Mode提供简单的状态管理,实际就是改变数据库存储的数值,来进行状态的切换. 安装1pip install django-fsm 用法1234from django_fsm import FSMField, transitionclass BlogPost(models.Model): state = FSMField(default='new') 1.在你的models模块新建一个Model模型,集成models.Model与django的Model的创建一样 建立一个state子段 是FSMField类型,它实际是继承FSMFieldMixin, models.CharField,所以它也是CharField类型 1234567class FSMField(FSMFieldMixin, models.CharField): """ State Machine support for Django model as CharField """ def __init__(self, *args, **kwargs): kwargs.setdefault('max_length', 50) super(FSMField, self).__init__(*args, **kwargs) 2.在你的BlogPost Model下声明一个publish方法,方法的名字可以随便定义不是固定的. 1234567891011121314import datetimedef can_publish(instance): # No publishing after 17 hours if datetime.datetime.now().hour &gt; 17: return False return Trueclass BlogPost(models.Model): state = FSMField(max_length=20,default='new') custom = &#123;'label': 'Publish', 'type': '*'&#125; @transition(field=state,source='start',target='pub',conditions=[can_publish,],custom=custom,on_error='failed',permission='polls.delete_blogpost') def publish(self): print('publish 执行') return 'publish' 3.用transition装饰器装饰刚才的publish方法,transition的具体逻辑如下 field为你在BlogPost模块定义的字段,我们定义了一个叫state的字段所以可以填写state source里面的字段值你可以随便定义,当你定义的source与你数据存储state的一致时(除了定义为*或+),当要 执行改变状态时,就会校验这个数值,是否不通过 target为检验通过以后当要改变状态时,把你的state改为你自己定义的内容,例如上文中我们定义了pub内容 conditions可以添加我们要使用的校验方法 on_error 当我们执行publish方法时抛出了异常,我们将异常捕获,那么数据库中的state字段就变成上面我们定义的failed,如果不捕获异常数据库中的state值不会变化 permission 校验当前用户是否具有该model模块某些权限,例如上面我们定义了polls.delete_blogpost 其中polls为你的app名称delete为删除权限也可以add,也可以其他的.blogpost为你的新建的Model模块 custom 自定义用 transition方法里面的具体内容 12345678910111213141516171819202122232425262728293031323334def transition(field, source='*', target=None, on_error=None, conditions=[], permission=None, custom=&#123;&#125;): """ Method decorator for mark allowed transitions Set target to None if current state needs to be validated and has not changed after the function call """ def inner_transition(func): #判断我们定义的方法是否有'_django_fsm'属性 wrapper_installed, fsm_meta = True, getattr(func, '_django_fsm', None) #刚开始我们定义的方法没有_django_fsm属性 if not fsm_meta: wrapper_installed = False #新建一个FSMMeta对象添加到我们定义的函数上 fsm_meta = FSMMeta(field=field, method=func) setattr(func, '_django_fsm', fsm_meta) if isinstance(source, (list, tuple, set)): #如果我们定义的source为list,tuple,set中的一种就会对source进行遍历操作添加到fsm_meta的transitions中,transitions为一个dict类型的 for state in source: func._django_fsm.add_transition(func, state, target, on_error, conditions, permission, custom) else: func._django_fsm.add_transition(func, source, target, on_error, conditions, permission, custom) @wraps(func) def _change_state(instance, *args, **kwargs):#当要改变状态时要执行的方法 return fsm_meta.field.change_state(instance, func, *args, **kwargs) if not wrapper_installed:#如果我们没有给我们定义的function添加_django_fsm属性那么我们在执行我们定义的function时,就会执行_change_state这个方法 return _change_state return func return inner_transition 类FSMMeta里面的具体内容 FSMMeta类中get_transition(self, source)与add_transition(source,…)方法中的source是不同的,get_transition方法中的source为我们数据库存储的数值,即我们的例子中当前state字段对应数据库中的数值,add_transition中的source为我们在装饰器中传递的参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class FSMMeta(object): """ Models methods transitions meta information """ def __init__(self, field, method): self.field = field#我们在Model中定义的字段 self.transitions = &#123;&#125; # source -&gt; Transition#存储以source为键,值为Transition()对象实例,该实例包含了我们定义的method方法,source字段,target字段,on_error字段,conditions字段,permission字段等 #获取FSMMeta对象实例 def get_transition(self, source): #从transitions字典中获取source键对应的Transition对象实例,source为我们数据库中的值 transition = self.transitions.get(source, None) #如果transition为空,即字典中没有保存source键对应的Transition对象实例 if transition is None: #判断以前我们是否用source是否用'*'作为source进行存储 transition = self.transitions.get('*', None) if transition is None: #判断以前我们是否用source是否用'+'作为source进行存储 transition = self.transitions.get('+', None) return transition #将source中的数值,以及Transition对象实例添加到transitions字典中,如果source为集合那么transitions中包含多个数值,source为我们在装饰器中填写的source参数值 def add_transition(self, method, source, target, on_error=None, conditions=[], permission=None, custom=&#123;&#125;): #如果source中包含重复字段就会抛出异常 if source in self.transitions: raise AssertionError('Duplicate transition for &#123;0&#125; state'.format(source)) #创建以source为键 Transition对象实例为值存入到transitions中 self.transitions[source] = Transition( method=method, source=source, target=target, on_error=on_error, conditions=conditions, permission=permission, custom=custom) #判断当前的状态,是否在transitions中.即我们数据库中state对应的数值是否在transitions中 def has_transition(self, state): """ Lookup if any transition exists from current model state using current method """ #判断当前的状态,是否在transitions中.即我们数据库中state对应的数值是否在transitions中 if state in self.transitions: return True #判断*是否在transitions中 if '*' in self.transitions: return True #判断*是否在transitions中并且当前state字段对应数据库中的值与target是否不同 if '+' in self.transitions and self.transitions['+'].target != state: return True return False #进行我们在conditions中添加的方法条件的判断,state为当前数据库中的状态值 def conditions_met(self, instance, state): """ Check if all conditions have been met """ #获取Transition实例对象 transition = self.get_transition(state) #没有Transition实例对象直接验证不通过 if transition is None: return False #如果conditions为空说明不进行条件判断 elif transition.conditions is None: return True else: """ conditions为列表,我们将作用于map函数,执行map函数 中的匿名lambda函数即执行conditions列表中的每一个函数,将返回的结果放到列表中 用all函数进行判断 """ return all(map(lambda condition: condition(instance), transition.conditions)) #进行权限的判断 def has_transition_perm(self, instance, state, user): #获取Transition对象实例 transition = self.get_transition(state) #如果Transition对象实例为空直接没有权限 if not transition: return False else: #判断transition中是否含有权限,user为登录的用户,一般为request.user return transition.has_perm(instance, user) #获取我们的传递过来的target数值 def next_state(self, current_state): transition = self.get_transition(current_state) if transition is None: raise TransitionNotAllowed('No transition from &#123;0&#125;'.format(current_state)) return transition.target #当异常抛出时,我们获取我们定义的on_error参数 def exception_state(self, current_state): transition = self.get_transition(current_state) if transition is None: raise TransitionNotAllowed('No transition from &#123;0&#125;'.format(current_state)) return transition.on_error 4.当我们执行我们定义的publish函数时,实际调用的是fsm_meta.field.change_state, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 def change_state(self, instance, method, *args, **kwargs): #meta为FSMMeta对象实例 meta = method._django_fsm #我们定义的函数的名字 method_name = method.__name__ current_state = self.get_state(instance) if not meta.has_transition(current_state): raise TransitionNotAllowed( "Can't switch from state '&#123;0&#125;' using method '&#123;1&#125;'".format(current_state, method_name), object=instance, method=method) if not meta.conditions_met(instance, current_state): raise TransitionNotAllowed( "Transition conditions have not been met for method '&#123;0&#125;'".format(method_name), object=instance, method=method) #获取target数值 next_state = meta.next_state(current_state) signal_kwargs = &#123; 'sender': instance.__class__, 'instance': instance, 'name': method_name, 'field': meta.field, 'source': current_state, 'target': next_state, 'method_args' : args, 'method_kwargs' : kwargs &#125;#调用pre_transition信号发送信号 pre_transition.send(**signal_kwargs) try: #调用我们定义的方法,并且获取返回结果 result = method(instance, *args, **kwargs) #如果target不为空 if next_state is not None: #判断target是否含有get_state属性,即判断target是否是RETURN_VALUE或者GET_STATE对象类型 #如果是就获取里面对应的数值 if hasattr(next_state, 'get_state'): next_state = next_state.get_state( instance, transition, result, args=args, kwargs=kwargs) signal_kwargs['target'] = next_state #把instance作为代理类 self.set_proxy(instance, next_state) self.set_state(instance, next_state) except Exception as exc: #如果发生异常就会获取error_state exception_state = meta.exception_state(current_state) if exception_state: self.set_proxy(instance, exception_state) self.set_state(instance, exception_state) signal_kwargs['target'] = exception_state signal_kwargs['exception'] = exc #发送信号 post_transition.send(**signal_kwargs) raise else: post_transition.send(**signal_kwargs) return result 在view试图函数中进行使用 1234567891011121314def list(self, request, *args, **kwargs): #校验conditions的验证方法 if not can_proceed(post.publish): raise PermissionError #进行权限的校验 if not has_transition_perm(post.publish,request.user): raise PermissionError try: post.publish(request=request) except Exception as e: pass post.save() return super(AnimalViewset, self).list(request, *args, **kwargs)]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
</search>
