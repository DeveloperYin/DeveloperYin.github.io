<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[django-fsm的用法]]></title>
    <url>%2F2018%2F07%2F26%2Fdjango-fsm%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[django有限状态机为django Mode提供简单的状态管理,实际就是改变数据库存储的数值,来进行状态的切换. 安装1pip install django-fsm 用法1234from django_fsm import FSMField, transitionclass BlogPost(models.Model): state = FSMField(default='new') 1.在你的models模块新建一个Model模型,集成models.Model与django的Model的创建一样 建立一个state子段 是FSMField类型,它实际是继承FSMFieldMixin, models.CharField,所以它也是CharField类型 1234567class FSMField(FSMFieldMixin, models.CharField): """ State Machine support for Django model as CharField """ def __init__(self, *args, **kwargs): kwargs.setdefault('max_length', 50) super(FSMField, self).__init__(*args, **kwargs) 2.在你的BlogPost Model下声明一个publish方法,方法的名字可以随便定义不是固定的. 1234567891011121314import datetimedef can_publish(instance): # No publishing after 17 hours if datetime.datetime.now().hour &gt; 17: return False return Trueclass BlogPost(models.Model): state = FSMField(max_length=20,default='new') custom = &#123;'label': 'Publish', 'type': '*'&#125; @transition(field=state,source='start',target='pub',conditions=[can_publish,],custom=custom,on_error='failed',permission='polls.delete_blogpost') def publish(self): print('publish 执行') return 'publish' 3.用transition装饰器装饰刚才的publish方法,transition的具体逻辑如下 field为你在BlogPost模块定义的字段,我们定义了一个叫state的字段所以可以填写state source里面的字段值你可以随便定义,当你定义的source与你数据存储state的一致时(除了定义为*或+),当要 执行改变状态时,就会校验这个数值,是否不通过 target为检验通过以后当要改变状态时,把你的state改为你自己定义的内容,例如上文中我们定义了pub内容 conditions可以添加我们要使用的校验方法 on_error 当我们执行publish方法时抛出了异常,我们将异常捕获,那么数据库中的state字段就变成上面我们定义的failed,如果不捕获异常数据库中的state值不会变化 permission 校验当前用户是否具有该model模块某些权限,例如上面我们定义了polls.delete_blogpost 其中polls为你的app名称delete为删除权限也可以add,也可以其他的.blogpost为你的新建的Model模块 custom 自定义用 transition方法里面的具体内容 12345678910111213141516171819202122232425262728293031323334def transition(field, source='*', target=None, on_error=None, conditions=[], permission=None, custom=&#123;&#125;): """ Method decorator for mark allowed transitions Set target to None if current state needs to be validated and has not changed after the function call """ def inner_transition(func): #判断我们定义的方法是否有'_django_fsm'属性 wrapper_installed, fsm_meta = True, getattr(func, '_django_fsm', None) #刚开始我们定义的方法没有_django_fsm属性 if not fsm_meta: wrapper_installed = False #新建一个FSMMeta对象添加到我们定义的函数上 fsm_meta = FSMMeta(field=field, method=func) setattr(func, '_django_fsm', fsm_meta) if isinstance(source, (list, tuple, set)): #如果我们定义的source为list,tuple,set中的一种就会对source进行遍历操作添加到fsm_meta的transitions中,transitions为一个dict类型的 for state in source: func._django_fsm.add_transition(func, state, target, on_error, conditions, permission, custom) else: func._django_fsm.add_transition(func, source, target, on_error, conditions, permission, custom) @wraps(func) def _change_state(instance, *args, **kwargs):#当要改变状态时要执行的方法 return fsm_meta.field.change_state(instance, func, *args, **kwargs) if not wrapper_installed:#如果我们没有给我们定义的function添加_django_fsm属性那么我们在执行我们定义的function时,就会执行_change_state这个方法 return _change_state return func return inner_transition 类FSMMeta里面的具体内容 FSMMeta类中get_transition(self, source)与add_transition(source,…)方法中的source是不同的,get_transition方法中的source为我们数据库存储的数值,即我们的例子中当前state字段对应数据库中的数值,add_transition中的source为我们在装饰器中传递的参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class FSMMeta(object): """ Models methods transitions meta information """ def __init__(self, field, method): self.field = field#我们在Model中定义的字段 self.transitions = &#123;&#125; # source -&gt; Transition#存储以source为键,值为Transition()对象实例,该实例包含了我们定义的method方法,source字段,target字段,on_error字段,conditions字段,permission字段等 #获取FSMMeta对象实例 def get_transition(self, source): #从transitions字典中获取source键对应的Transition对象实例,source为我们数据库中的值 transition = self.transitions.get(source, None) #如果transition为空,即字典中没有保存source键对应的Transition对象实例 if transition is None: #判断以前我们是否用source是否用'*'作为source进行存储 transition = self.transitions.get('*', None) if transition is None: #判断以前我们是否用source是否用'+'作为source进行存储 transition = self.transitions.get('+', None) return transition #将source中的数值,以及Transition对象实例添加到transitions字典中,如果source为集合那么transitions中包含多个数值,source为我们在装饰器中填写的source参数值 def add_transition(self, method, source, target, on_error=None, conditions=[], permission=None, custom=&#123;&#125;): #如果source中包含重复字段就会抛出异常 if source in self.transitions: raise AssertionError('Duplicate transition for &#123;0&#125; state'.format(source)) #创建以source为键 Transition对象实例为值存入到transitions中 self.transitions[source] = Transition( method=method, source=source, target=target, on_error=on_error, conditions=conditions, permission=permission, custom=custom) #判断当前的状态,是否在transitions中.即我们数据库中state对应的数值是否在transitions中 def has_transition(self, state): """ Lookup if any transition exists from current model state using current method """ #判断当前的状态,是否在transitions中.即我们数据库中state对应的数值是否在transitions中 if state in self.transitions: return True #判断*是否在transitions中 if '*' in self.transitions: return True #判断*是否在transitions中并且当前state字段对应数据库中的值与target是否不同 if '+' in self.transitions and self.transitions['+'].target != state: return True return False #进行我们在conditions中添加的方法条件的判断,state为当前数据库中的状态值 def conditions_met(self, instance, state): """ Check if all conditions have been met """ #获取Transition实例对象 transition = self.get_transition(state) #没有Transition实例对象直接验证不通过 if transition is None: return False #如果conditions为空说明不进行条件判断 elif transition.conditions is None: return True else: """ conditions为列表,我们将作用于map函数,执行map函数 中的匿名lambda函数即执行conditions列表中的每一个函数,将返回的结果放到列表中 用all函数进行判断 """ return all(map(lambda condition: condition(instance), transition.conditions)) #进行权限的判断 def has_transition_perm(self, instance, state, user): #获取Transition对象实例 transition = self.get_transition(state) #如果Transition对象实例为空直接没有权限 if not transition: return False else: #判断transition中是否含有权限,user为登录的用户,一般为request.user return transition.has_perm(instance, user) #获取我们的传递过来的target数值 def next_state(self, current_state): transition = self.get_transition(current_state) if transition is None: raise TransitionNotAllowed('No transition from &#123;0&#125;'.format(current_state)) return transition.target #当异常抛出时,我们获取我们定义的on_error参数 def exception_state(self, current_state): transition = self.get_transition(current_state) if transition is None: raise TransitionNotAllowed('No transition from &#123;0&#125;'.format(current_state)) return transition.on_error 4.当我们执行我们定义的publish函数时,实际调用的是fsm_meta.field.change_state, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 def change_state(self, instance, method, *args, **kwargs): #meta为FSMMeta对象实例 meta = method._django_fsm #我们定义的函数的名字 method_name = method.__name__ current_state = self.get_state(instance) if not meta.has_transition(current_state): raise TransitionNotAllowed( "Can't switch from state '&#123;0&#125;' using method '&#123;1&#125;'".format(current_state, method_name), object=instance, method=method) if not meta.conditions_met(instance, current_state): raise TransitionNotAllowed( "Transition conditions have not been met for method '&#123;0&#125;'".format(method_name), object=instance, method=method) #获取target数值 next_state = meta.next_state(current_state) signal_kwargs = &#123; 'sender': instance.__class__, 'instance': instance, 'name': method_name, 'field': meta.field, 'source': current_state, 'target': next_state, 'method_args' : args, 'method_kwargs' : kwargs &#125;#调用pre_transition信号发送信号 pre_transition.send(**signal_kwargs) try: #调用我们定义的方法,并且获取返回结果 result = method(instance, *args, **kwargs) #如果target不为空 if next_state is not None: #判断target是否含有get_state属性,即判断target是否是RETURN_VALUE或者GET_STATE对象类型 #如果是就获取里面对应的数值 if hasattr(next_state, 'get_state'): next_state = next_state.get_state( instance, transition, result, args=args, kwargs=kwargs) signal_kwargs['target'] = next_state #把instance作为代理类 self.set_proxy(instance, next_state) self.set_state(instance, next_state) except Exception as exc: #如果发生异常就会获取error_state exception_state = meta.exception_state(current_state) if exception_state: self.set_proxy(instance, exception_state) self.set_state(instance, exception_state) signal_kwargs['target'] = exception_state signal_kwargs['exception'] = exc #发送信号 post_transition.send(**signal_kwargs) raise else: post_transition.send(**signal_kwargs) return result 在view试图函数中进行使用 1234567891011121314def list(self, request, *args, **kwargs): #校验conditions的验证方法 if not can_proceed(post.publish): raise PermissionError #进行权限的校验 if not has_transition_perm(post.publish,request.user): raise PermissionError try: post.publish(request=request) except Exception as e: pass post.save() return super(AnimalViewset, self).list(request, *args, **kwargs)]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2018%2F07%2F26%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
